rex-cli: REX command line interface
===================================

Программа служит для запуска конвертеров и одновременно представляет из себя пример использования библиотек конвертеров.

Ключи командной строки:

 - -i - файл, откуда берутся входные данные
 - -o - файл, куда записываются выходные данные
 - -d - файл, откуда берутся словари, доступен впоследствии через **task.config.dicfile**
 - -f - название формата, из которого будет производиться преобразование в формат REX
 - -t - название формата, в который из формата REX будет производиться преобразование
 - -v - чуть более подробный вывод
 - --force - осуществлять преобразование даже в том случае, если входные данные не прошли валидацию

Если не задан ключ -i, данные читаются со стандартного входа.
Если не задан ключ -o, данные пишутся на стандартный выход.

Преобразование всегда осуществляется либо в формат REX, либо из него. То есть, следует использовать либо
ключ -f, либо ключ -t. Если указаны оба, будет работать ключ -f, то есть, будет осуществляться преобразование из указанного формата в формат REX.

Подробнее о формате REX: [https://github.com/vne/rex-format](https://github.com/vne/rex-format)

Кроме того, здесь ещё присутствует рабочий [пример конвертера](https://github.com/vne/rex-format/tree/master/rex-cli/convert/winner) для формата [Winner](https://baza-winner.ru/winner/support/xml-template.html).

Используются несколько вспомогательных библиотек, которые либо упрощают жизнь при написании конвертера, либо используются во фреймворке, который эти конвертеры запускает:

   - [errh](https://github.com/vne/errh) - коллекционирование ошибок
   - [rex-stat](https://github.com/vne/rex-stat) - сбор статистики об обработанных объектах недвижимости
   - [Dicset](https://github.com/vne/Dicset) - работа со словарями для преобразования данных
   - [Saxmlp](https://github.com/vne/saxmlp) - обёртка для XML-парсера, позволяющая вешать обработчики на XPath-выражения, и умеющая, к тому же, валидацию XML по XSD-схемам
   - [js2xml](https://github.com/vne/jso2xml) - преобразование объектов Javascript в XML (функциональность, аналогичная xml2js Builder; в будущем, вероятно, будет упразднена)

Экземпляр класса **ErrorHandler** из библиотеки _errh_ передаётся функциям в аргументе **task.error**. Экземпляр класса **REXStat** из библиотеки _rex-stat_ передаётя в аргументе **task.stat**. Об использовании этих классов см. ниже в разделах про логи и статистику, а также в разделе про API.


Пара слов об общей архитектуре
------------------------------

Конвертер - это вторая из трёх частей процесса переноса информации из одного хранилища в другое. Эти три части:

 1. получение данных из источника
 2. преобразование
 3. загрузка преобразованных данных туда, куда нужно

Иными словами, это процесс [ETL](http://en.wikipedia.org/wiki/Extract,_transform,_load) - extract, transform, load.

У нас фазы процесса называются **fetch**, **convert** и **publish**. Конвертер занимается только (sic!) конверсией (фазой convert).

Это значит, что конвертер не должен самостоятельно заниматься чтением файлов, парсингом сайтов или сохранением данных куда бы то ни было. Он получает на вход структуру данных (описанную ниже) и возвращает другую структуру, на этом его работа заканчивается.

Загрузка данных из источниках (**fetch**) и сохранение где-то (**publish**) - это отдельные фазы, для которых пишутся отдельные скрипты (иногда довольно простые).

Совокупность трёх скриптов - по одному на каждую фазу - определяет задачу по импорту или экспорту данных. Задача описывается в специальном файле конфигурации задачи. Эта конфигурация доступна во время выполнения в виде параметра config первого аргумента, передаваемого в функции **import**, **export** и **validate** (см. ниже).

Разумеется, скрипты эти не совсем независимы друг от друга. Например, при импорте скрипт **fetch** может возвращать данные, вытащенные из совершенно невнятного источника (например, после разбора HTML какого-то сайта). В этом случае скрипт **convert** должен уметь работать с этими невнятными данными. Однако уже скрипт фазы **publish** для импорта может быть один на всех (загрузить данные в формате REX во внутреннюю базу данных). При экспорте скрипт фазы **fetch** - один на всех (взять данные из внутренней базы и сохранить в формате REX), скрипты фазы **publish** - по одному на каждый способ доставки (положить в директорию, обслуживаемую веб-сервером, загрузить по FTP, отправить по почте, etc).

Программа [rex-cli](rex-cli.js) заменяет первую и третью фазы (**fetch** и **publish**) на чтение и запись файлов. Она годится только для тестирования конвертеров.

Логи и ошибки
-------------

Сообщения об ошибках делятся на две категории: ошибки, относящиеся ко входным данным, и технические ошибки. Эти две категории должны обрабатываться по-разному.
Ошибки о входных данных нужно регистрировать так, чтобы их потом можно было отправить необученному риэлтеру для того, чтобы он их исправил. Технические ошибки (и шире - вообще сообщения о работе программы) должны писаться в лог. Общее правило такое: в лог пишется то, что поможет программисту, поддерживающему проект, разобраться в том, что происходит, что когда и куда конвертировалось и что из этого вышло, ошибки же о входных данных регистрируются с помощью специальной функции.

**console.log** (и **console.error** и т.д.) использовать можно, но лучше считать, что всё, что пишется с его помощью, никто никогда не увидит. То есть,
**console.log** можно использовать при отладке, но не для информирования кого-то о чём-то.

### Технические логи

Для ведения технических логов в каждую функцию преобразования передаётся объект **log** (вообще, об аргументах и их смысле см. ниже разделы про API):

	function import(task) {
		task.log("Some message", "and", "several arguments");
		task.log.error("Some error message");
		task.log.progress("50% done");
		task.log.debug("Redundant information");
	}

То есть, логгер можно вызывать как функцию (это соответствует уровню _info_), а можно вызывать один из его методов:

 - error - ошибка
 - alert - предупреждение
 - info - какая-то информация
 - debug - отладочная информация
 - progress - информация о прогрессе в выполнении задачи (скажем, процент выполнения)

Аргументы во все эти функции можно передавать так же, как в функцию **console.log**.

Стоит ещё раз подчеркнуть, что этот логгер предназначен именно для технической информации. Скажем, не удаётся загрузить модуль, не удаётся прочитать файл, то-то сделано, то-то сейчас будет делаться или сделано на столько-то процентов.

### Ошибки во входных данных

Обо всех несуразицах во входных данных имеет смысл проинформировать тех людей, которые эти данные отправили. Поэтому все случаи, когда данные отправлены не в том формате, когда они битые, когда XML невалиден, когда в каком-то поле по смыслу должно быть одно, а присутствует другое - все такие случаи необходимо регистрировать с помощью объекта **error**, передаваемого в каждую функцию преобразования:

	function import(task) {
		task.error.info(11, "Хороший, хороший объект... Просто решили вам об этом сообщить");
		task.error.warn(34, "Неправильно заполнено поле с жилой площадью, мы его проигнорировали, учтите на будущее");
		task.error.fatal(45, "Объект не удалось преобразовать из-за того, что он нам не понравился");
		task.error.fatal("Вообще всё плохо"); // Здесь аргумент с id объекта опущен!
	}

У этого объекта есть три метода:

 - info
 - warn
 - fatal

Все три метода принимают два аргумента: первый - id объекта, второй - сообщение. Метод **info** предназначен для простого информирования риэлтора о чём-то (и вряд ли нужен на практике). Метод **warn** предназначен для сообщения о некритических ошибках, скажем, необязательное поле заполнено неверно. Метод **fatal** регистрирует такие ошибки, из-за которых дальнейшая обработка объекта становится невозможной, например, не заполнено обязательное поле.

Вообще, id объекта можно не передавать - например, когда нам нужно сообщить о том, что поле с идентификатором объекта не заполнено. Однако надо понимать, что риэлтор в таком случае вряд ли поймёт, к чему относится сообщение об ошибке. В качестве id здесь может выступать любая информация, а не только номер, поэтому можно передать первым аргументом адрес или ещё что-то, что поможет риэлтору найти и исправить ошибку. Для XML-форматов чаще всего достаточно указать непосредственно номер объекта. Для текстовых форматов это может быть номер строки.

### Ошибки, препятствующие работе конвертера

Функции **import**, **export** и **validate** - асинхронные, результаты своей деятельности они возвращают через _callback_-функции. Поэтому они не должны бросать исключений. Для передачи наверх сообщения об ошибке, из-за которой невозможно продолжать работу, им следует использовать первый аргумент _callback_-функции. Если работа заканчивается штатно, то первый аргумент должен быть null (или undefined).

Если всё плохо и конвертер не может работать (например, отсутствует файл со словарями или какие-то другие ресурсы), то можно досрочно вызывать _callback_-функцию с описанием ошибки в первом аргументе и достойно умереть. В этом случае можно и нужно использовать логи для прояснения ситуации.


Сбор статистики
---------------

Когда через конвертеры проходит много данных, нужно иметь возможность собирать и анализировать какую-то статистику по ним. Разумеется, собирать и обрабатывать статистику - не задача конвертера, однако только конвертер имеет доступ к объекту сделки не как к строке, а как к данным. Поэтому конвертер должен в функциях **import** и **export** вызывать функцию сбора статистики и передавать ей данные в формате REX. В функции **import** это будут данные после преобразования, в функции export - до.

В конвертере сбор статистики доступен через объект **task.stat**. У этого объекта есть два метода:

 - ok
 - fail

Метод **ok** регистрирует объект после удачного преобразования, метод **fail** - после неудачного. Вот пример кода:

	var res = exportOrder(task, order, dic);
	// if there is a result
	if (res) {
		// add the order to statistics as converted
		task.stat.ok(order);
		// process the conversion results...
	} else {
		// add the order to statistics as failed
		task.stat.fail(order);
	}

Нюанс заключается в том, что объект в формате REX должен быть представлен в нотации библиотеки [xml2js](https://github.com/Leonidas-from-XIV/node-xml2js), так как функция сбора статистики опирается на такое представление объектов. Вполне возможно, что конвертер не использует эту библиотеку. В этом случае можно передать в функцию сбора статистики строку с XML-фрагментом, описывающим один объект, функция тогда будет разбирать его самостоятельно.


Валюта и её курсы
-----------------

Чаще всего в рекламных изданиях по недвижимости в России используются рубли. Однако бывают нюансы, а кроме них, бывает ещё и зарубежная недвижимость. Чаще всего в этих случаях цена объекта прямо указывается в валюте. В этом случае в формате REX в атрибуте currency тегов price > full и price > per_meter указывается идентификатор этой валюты (EUR, USD, etc). Если атрибут currency опущен, считается, что он равен RUR, то есть, стоимость указана в российских рублях.

Однако бывают ситуации, когда цена указана в одной валюте, а в рекламе должна появиться в другой. В этом случае можно вычислить нужную сумму, используя текущий курс валюты. Для выяснения курса можно использовать следующие функции:

 - task.currency.rate - принимает ID валюты в виде строки, возвращает последний известный курс по отношению к рублю. Если валюта не известна, возвращает null.
 - task.currency.to - принимает ID валюты и сумму в рублях, возвращает сумму в валюте. Если валюта не найдена, возвращает второй аргумент
 - task.currency.from - принимает ID валюты и сумму в этой валюте, возвращает сумму в рублях. Если валюта не найдена, возвращает второй аргумент.

Последние две функции умножают и делят числа и возвращают результат, никак его не форматируя. Для приведения к человекочитаемому виду используйте .toFixed или что-то ещё.

Пока что гарантируется наличие курсов двух валют: евро (EUR) и долларов (USD). Возможно, в будущем появятся ещё.


Примеры
-------

Примеры конвертеров находятся в директории convert. Каждый конвертер лежит в своей директории внутри директории convert и является вполне автономным пакетом. Подключение конвертеров происходит следующим образом:

	var converter = require('./convert/' + format);

То есть, точка входа должна либо находиться в файле index.js, либо в директории конвертера должен присутствовать файл package.json, в котором указана точка входа. Пример: конвертер bad, находящийся в файле bad.js.

В настоящий момент имеется три примера.

### null

Конвертер, всегда возвращающий null. Фактически, пользы от него - только названия функций.

### copy

Конвертер, возвращающий входные данные в неизменном виде. Польза - структура выходных данных.

### bad

Конвертер, возвращающий входные данные плюс какие-то сообщения об ошибках. Польза, соответственно, в этих сообщениях.

### winner

Конвертер для формата Winner, реализующий преобразование для объектов Санкт-Петербурга и Ленобласти. Представляет собой образец XML->XML-преобразования, можно использовать его для написания других конвертеров по аналогии. В нём реализованы все три функции: импорт, экспорт и валидация.

Этот конвертер опирается на несколько вспомогательных библиотек:

 - [saxmlp](convert/winner/node_modules/saxmlp) - парсинг и валидация XML, основана на SAX.js
 - [Dicset](convert/winner/node_modules/Dicset) - работа со словарями
 - [js2xml](convert/winner/node_modules/js2xml) - преобразование объектов Javascript в строку XML (в некотором смысле, обратное преобразование для xml2js, но формат объектов не совместим с xml2js, работающем в режиме по умолчанию)

API модулей, реализующих добычу данных (фаза fetch)
---------------------------------------------------

Модуль должен реализовывать одну функцию fetch, принимающую два аргумента: первый - объект, описывающий задачу, второй - _callback_-функция, вызываемая по завершении загрузки данных из источника.

Объект, описывающий задачу, выглядит так:

	{
		"format": "название формата",
		"config": "конфигурация задачи (всей задачи, а не только задачи загрузки данных)",
		"log": "логгер для технической информации",
		"__file": "путь к модулю, в котором находится функция fetch"
	}

_callback_-функция принимает два аргумента: объект ошибки и объект с данными. Если объект ошибки определён, то это означает, что в процессе загрузки данных произошло нечто, из-за чего дальнейшая работа невозможна. Ошибка записывается в лог и программа останавливается.
Объект с данными - это, скорее всего, массив объектов, но в принципе - может быть всё, что угодно, что поймёт конвертер из следующей фазы процесса.

API модулей, реализующих преобразование данных (фаза convert)
-------------------------------------------------------------

Конвертер должен реализовывать три основные функции:

 - import - преобразование из внешнего формата в формат REX
 - export - обратное преобразование
 - validate - проверка данных во внешнем формате на валидность

Внутри себя конвертер может состоять из каких угодно функций, файлов, библиотек и т.д. Если используются какие-то внешние библиотеки, должен присутствовать файл package.json, в котором эти библиотеки перечислены. Таким образом, установка конвертера сводится к копированию файлов и последующему выполнению

	npm install

На вход каждой из этих функций подаются два аргумента: объект, описывающий задачу, и _callback_-функция, которая вызывается после завершения преобразования. Объект, описывающий задачу, выглядит так:

	{
		"data": "массив данных",
		"format": "название формата",
		"config": "конфигурация задачи (всей задачи, а не только задачи преобразовани)",
		"log": "логгер для технической информации",
		"error": "сборщик ошибок в объектах недвижимости",
		"stat": "сборщик статистики по объектам недвижимости"
		"__file": "путь к пакету конвертера, в котором находятся функции import, export и validate"
	}

На входе у функции export данные будут в формате REX, на входе у двух других - во внешнем формате.

_callback_-функция принимает два аргумента: объект ошибки и объект, описывающий результат выполнения.

### Функции import и export

Функции import и export должны вызвать _callback_-функцию по завершении работы. В эту функцию они передают два аргумента: объект ошибки и структуру данных, описывающую результат выполнения:

	{
		data: "преобразованные данные: либо строка, либо объект",
		from: "название формата, из которого осуществлялось преобразование",
		to: "название формата, в который осуществлялось преобразование",
		meta: "массив с метаданными",
		errors: "объект регистратора ошибок (task.error)"
	}

Предполагается, что объект ошибки (первый аргумент) определён только в том случае, когда происходит какая-то непоправимая техническая ошибка, не связанная со входными данными. Все ошибки, касающиеся входных данных, должны регистрироваться с помощью обработчика ошибок task.error (см. подробнее раздел про логи и ошибки). Если данные можно преобразовать частично (скажем, часть объектов описаны корректно, часть - нет), то в data должны быть преобразованные данные, в errors - описание ошибок.

В качестве параметра errors достаточно передать объект **task.error**.

Объект meta нужен в том случае, когда конвертер должен сообщить модулю отправки данных какую-то дополнительную информацию. Например, издание принимает XML-файл и файл с zip-архивом изображений. Конвертер формирует XML-файл со ссылками на фотографии объектов, а в объекте meta передаёт информацию о том, какие изображения модуль отправки данных должен взять и заархивировать. Подробнее см. ниже раздел про метаданные.


### Функция validate

Функция validate служит для проверки валидности данных во внешнем формате. Для XML это может быть соответствие схеме, для текстовых форматов - соответствие каждой строки регулярному выражению или ещё что-то.

После окончания валидации вызывается _callback_-функция с двумя аргументами: объект ошибки и результаты работы. Объект ошибки должен быть определён только в том случае, если произошла ошибка, не связанная со входными данными. Для регистрации результатов валидации нужно использовать объект **task.error** и его же и возвращать, если валидация не прошла.

Может быть так, что функции **import** и **validate** возвращают одинаковый набор ошибок, однако может и не быть; это зависит от формата. Скажем, соответствие XML схеме не всегда гарантирует логическую непротиворечивость данных. При преобразовании такие противоречия могут всплыть. Поэтому под проверкой валидности здесь понимается, скорее, быстрая проверка на синтаксическую корректность, использование нужных типов данных и т.д.

### Метаданные

Метаданные нужны для того, чтобы описать какие-то действия, которые модуль отправки данных должен дополнительно произвести перед, собственно, отправкой в рекламное агентство. То есть, в первую очередь, метаданные нужны при экспорте в некоторые форматы. Например, какое-то издание может принимать фотографии только определённого размера. Конвертер не должен сам пережимать картинки, у него нет доступа к этим картинкам, есть только метаинформация о них (см. формат REX, тег _meta_). Конвертер по каждой картинке каждого объекта может выдать инструкцию о том, что с этой картинкой следует сделать.

Другой пример - издание принимает XML-файл и архив с картинками; в XML-файле идут ссылки на картинки из архива. В этом случае, конвертер должен в метаданных выдать инструкцию по архивированию необходимых картинок.

Вероятно, у метаданных могут быть и будут и другие применения, но сейчас пока ограничимся картинками.

Чаще всего метаданные вообще не будут нужны. Рекламных изданий, определяющих какие-то жёсткие требования к медиаматериалам, постепенно становится всё меньше. Если всё же они нужны, то это должен быть массив, состоящий из записей следующего вида:

	{
		"id": "ID объекта, как обсуждалось выше",
		"actions": [
			{
				"action": "resize_attachment",
				"url": "http://www.google.com/attachment.jpg",
				"width": 200,
				"height": 100
			},
			{
				"action": "dance_jig",
				"where": "Dublin"
			},
			{
				"action": "archive",
				"name": "pictures.zip",
				"type": "zip",
				"files": [ "http://url.of/image1.jpg", "http://url.of/image3.jpg", "http://url.of/image10.jpg" ]
			}
		]
	}

Массив **actions** состоит из записей, единственным обязательным атрибутом которых является атрибут **action**. Остальные атрибуты зависят от действия. Для действия **resize\_attachment** нужны атрибуты **url** (это должен быть URL файла из тега _meta > attachments > attachment > url_ в формате REX), **width** и **height** (новые размеры).

Если конвертер не предоставил метаинформации о сопутствующих объекту недвижимости файлах, то модуль, отправляющий рекламу, сам решает, какие файлы приложить к объекту.

Если конвертер вернул какую-то метаинформацию о сопутствующих файлах, то будут отправлены только те файлы, которые отобрал конвертер. Таким образом, конвертер может, например, ограничить количество отправляемых файлов, просто перечислив нужные в массиве с метаинформацией.

На данный момент, действия могут быть следующие:

 - resize\_attachment - изменить размер графического файла. Касается только изображений, остальные вложенные файлы будут проигнорированы (и не будут отправлены).
 - copy\_attachment - просто взять графический файл как есть. Касается только изображений. Это действие нужно как раз для ограничения количества или какого-то хитрого отбора отправляемых изображений.
 - archive - добавить файл в архив. Имя архива берётся из параметра **name**, тип - из параметра **type**, список файлов - из параметра **files**. Тип пока что может быть только один: **zip**. Параметр **files** опционален и может отсутствовать, в этом случае будут обработаны все файлы, относящиеся к объекту. Файлы в параметре **files** адресуются по URL и не могут не принадлежать обрабатываемому объекту. То есть, грубо говоря, если указать среди файлов "http://www.google.com/some.evil.file.jpg", он не будет обработан.


API модулей, реализующих публикацию данных (фаза publish)
---------------------------------------------------------

TODO: написать

Вообще, авторам конвертеров эта часть не нужна.
