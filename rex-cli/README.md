rex-cli: REX command line interface
===================================

Программа служит для запуска конвертеров и одновременно представляет из себя пример использования библиотек конвертеров.

Ключи командной строки:

 - -i - файл, откуда берутся входные данные
 - -o - файл, куда записываются выходные данные
 - -d - файл, откуда берутся словари
 - -f - название формата, из которого будет производиться преобразование в формат REX
 - -t - название формата, в который из формата REX будет производиться преобразование
 - -v - чуть более подробный вывод
 - --force - осуществлять преобразование даже в том случае, если входные данные не прошли валидацию

Если не задан ключ -i, данные читаются со стандартного входа.
Если не задан ключ -o, данные пишутся на стандартный выход.

Преобразование всегда осуществляется либо в формат REX, либо из него. То есть, следует использовать либо
ключ -f, либо ключ -t. Если указаны оба, будет работать ключ -f, то есть, будет осуществляться преобразование из указанного формата в формат REX.

Подробнее о формате REX: [https://github.com/vne/rex-format](https://github.com/vne/rex-format)

Пара слов об общей архитектуре
------------------------------

Конвертер - это вторая из трёх частей процесса переноса информации из одного хранилища в другое. Эти три части:

 1. получение данных из источника
 2. преобразование
 3. загрузка преобразованных данных туда, куда нужно

Иными словами, это процесс [ETL](http://en.wikipedia.org/wiki/Extract,_transform,_load) - extract, transform, load.

У нас фазы процесса называются fetch, convert и publish. Конвертер занимается только (sic!) конверсией (фазой convert).

Это значит, что конвертер не должен самостоятельно заниматься чтением файлов, парсингом сайтов или сохранением данных куда бы то ни было. Он получает на вход структуру данных (описанную ниже) и возвращает другую структуру, на этом его работа заканчивается.

Загрузка данных из источниках (fetch) и сохранение где-то (publish) - это отдельные фазы, для которых пишутся отдельные скрипты (иногда довольно простые).

Совокупность трёх скриптов - по одному на каждую фазу - определяет задачу по импорту или экспорту данных. Задача описывается в специальном файле конфигурации задачи. Эта конфигурация доступна во время выполнения в виде параметра config первого аргумента, передаваемого в функции import, export и validate (см. ниже).

Разумеется, скрипты эти не совсем независимы друг от друга. Например, при импорте скрипт fetch может возвращать данные, вытащенные из совершенно невнятного источника (например, после разбора HTML какого-то сайта). В этом случае скрипт convert должен уметь работать с этими невнятными данными. Однако уже скрипт фазы publish для импорта может быть один на всех (загрузить данные в формате REX во внутреннюю базу данных). При экспорте скрипт фазы fetch - один на всех (взять данные из внутренней базы и сохранить в формате REX), скрипты фазы publish - по одному на каждый способ доставки (положить в директорию, обслуживаемую веб-сервером, загрузить по FTP, отправить по почте, etc).

Программа [rex-cli](rex-cli.js) заменяет первую и третью фазы (fetch и publish) на чтение и запись файлов. Она годится только для тестирования конвертеров.

Примеры
-------

Примеры конвертеров находятся в директории convert. Каждый конвертер лежит в своей директории внутри директории convert и является вполне автономным пакетом. Подключение конвертеров происходит следующим образом:

	var converter = require('./convert/' + format);

То есть, точка входа должна либо находиться в файле index.js, либо в директории конвертера должен присутствовать файл package.json, в котором указана точка входа. Пример: конвертер bad, находящийся в файле bad.js.

В настоящий момент имеется три примера.

### null

Конвертер, всегда возвращающий null. Фактически, пользы от него - только названия функций.

### copy

Конвертер, возвращающий входные данные в неизменном виде. Польза - структура выходных данных.

### bad

Конвертер, возвращающий входные данные плюс какие-то сообщения об ошибках. Польза, соответственно, в этих сообщениях.

API модулей, реализующих добычу данных (фаза fetch)
---------------------------------------------------

Модуль должен реализовывать одну функцию fetch, принимающую два аргумента: первый - объект, описывающий задачу, второй - callback-функция, вызываемая по завершении загрузки данных из источника.

Объект, описывающий задачу, выглядит так:

	{
		"format": "название формата",
		"config": "конфигурация задачи (всей задачи, а не только задачи загрузки данных)",
		"__file": "путь к модулю, в котором находится функция fetch"
	}

Callback-функция принимает один аргумент - объект с данными. Скорее всего, это должен быть массив объектов, но в принципе это может быть всё, что угодно, что поймёт конвертер из следующей фазы процесса.

API модулей, реализующих преобразование данных (фаза convert)
-------------------------------------------------------------

Конвертер должен реализовывать три основные функции:

 - import - преобразование из внешнего формата в формат REX
 - export - обратное преобразование
 - validate - проверка данных во внешнем формате на валидность

Внутри себя конвертер может состоять из каких угодно функций, файлов, библиотек и т.д. Если используются какие-то внешние библиотеки, должен присутствовать файл package.json, в котором эти библиотеки перечислены. Таким образом, установка конвертера сводится к копированию файлов и последующему выполнению

	npm install

На вход каждой из этих функций подаются два аргумента: объект, описывающий задачу, и callback-функция, которая вызывается после завершения преобразования. Объект, описывающий задачу, выглядит так:

	{
		"data": "массив данных",
		"format": "название формата",
		"config": "конфигурация задачи (всей задачи, а не только задачи преобразовани)",
		"__file": "путь к пакету конвертера, в котором находятся функции import, export и validate"
	}

На входе у функции export данные будут в формате REX, на входе у двух других - во внешнем формате.

Callback-функция принимает один аргумент, описывающий результат выполнения.

### Функции import и export

Функции import и export передают в callback-функцию одинаковую структуру данных:

	{
		data: "преобразованные данные",
		from: "название формата, из которого осуществлялось преобразование",
		to: "название формата, в который осуществлялось преобразование",
		meta: "массив с метаданными",
		errors: "массив с ошибками"
	}

Предполагается, что функции import и export бросают исключения только в том случае, когда они не могут ничего преобразовать, данные пустые, повреждены, нечитаемы, etc. Если данные прочитать можно, но они не валидны, функции должны вернуть null в data и описание ошибки (или ошибок) в массиве errors. Если данные можно преобразовать частично (скажем, часть объектов описаны корректно, часть - нет), то в data должны быть преобразованные данные, в errors - описание ошибок.

Массив ошибок содержит список ошибок в формате

	{
		"id": "какой-то идентификатор объекта с ошибкой",
		"error": "описание ошибки по-русски или по-английски"
	}

Здесь ID - это любая информация, позволяющая однозначно определить, к какому объекту относится ошибка. Для XML-форматов это, скорее всего, будет непосредственно ID объекта. Для текстовых форматов это может быть номер строки.

Описание ошибки в идеале должно быть таким, чтобы его можно было дать почитать риэлтору, который ничего не смыслит в программировании, но понимает в объектах недвижимости.

### Функция validate

Функция validate служит для проверки валидности данных во внешнем формате. Для XML это может быть соответствие схеме, для текстовых форматов - соответствие каждой строки регулярному выражению или ещё что-то.

Функция возвращает массив, аналогичный описанному выше массиву errors.

Может быть так, что функции import и validate возвращают одинаковый набор ошибок, однако может и не быть. Скажем, соответствие XML схеме не всегда гарантирует логическую непротиворечивость данных. При преобразовании такие противоречия могут всплыть. Поэтому под проверкой валидности здесь понимается, скорее,быстрая проверка на синтаксическую корректность, использование нужных типов данных и т.д.

### Метаданные

Метаданные нужны для того, чтобы описать какие-то действия, которые необходимо произвести перед отправкой результатов преобразования в рекламное агентство. То есть, в первую очередь, они касаются экспорта. Например, какое-то издание может принимать фотографии только определённого размера. Конвертер не должен сам пережимать картинки, у него нет доступа к этим картинкам, есть только метаинформация о них (см. формат REX, тег meta). Конвертер по каждой картинке каждого объекта может выдать инструкцию о том, что с этой картинкой следует сделать.

Вероятно, у метаданных могут быть и будут и другие применения, но сейчас пока ограничимся картинками.

Чаще всего метаданные вообще не будут нужны. Рекламных изданий, определяющих какие-то жёсткие требования к медиаматериалам, постепенно становится всё меньше. Если всё же они нужны, то это должен быть массив, состоящий из записей следующего вида:

	{
		"id": "ID объекта, как обсуждалось выше",
		"actions": [
			{
				"action": "resize_attachment",
				"url": "http://www.google.com/attachment.jpg",
				"width": 200,
				"height": 100
			},
			{
				"action": "dance_jig",
				"where": "Dublin"
			}
		]
	}

Массив actions состоит из записей, единственным обязательным атрибутом которых является атрибут action. Остальные атрибуты зависят от действия. Для действия resize_attachment нужны атрибуты url (это должен быть URL файла из тега meta > attachments > attachment > url в формате REX), width и height (новые размеры).

Если конвертер не предоставил метаинформации о сопутствующих объекту недвижимости файлах, то модуль, отправляющий рекламу, сам решает, какие файлы приложить к объекту.

Если конвертер вернул какую-то метаинформацию о сопутствующих файлах, то будут отправлены только те файлы, которые отобрал конвертер. Таким образом, конвертер может, например, ограничить количество отправляемых файлов, просто перечислив нужные в массиве с метаинформацией.

На данный момент, действия могут быть следующие:

 - resize_attachment - изменить размер графического файла. Касается только изображений, остальные вложенные файлы будут проигнорированы (и не будут отправлены).
 - copy_attachment - просто взять графический файл как есть. Касается только изображений. Это действие нужно как раз для ограничения количества или какого-то хитрого отбора отправляемых изображений.

API модулей, реализующих публикацию данных (фаза publish)
---------------------------------------------------------

TODO: написать

Вообще, авторам конвертеров эта часть, скорее всего, не нужна.
